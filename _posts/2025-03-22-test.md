---
layout: post
title: "CTF密码学题解：RSA & 维吉尼亚密码"
date: 2025-03-21
categories: [CTF, Cryptography]
tags: [RSA, Vigenere, Crypto]
author: yuhuofeng
---

### RSA-baby

题目描述:

```python
from Crypto.Util.number import bytes_to_long, getPrime
from hashlib import md5
from random import randint
from gmpy2 import invert,gcd

#Hash Function:
def MD5(m):return md5(str(m).encode()).hexdigest()

#RSA AlgorithmParameter Generation Function:
def KeyGen():
	Factor_BitLength = 30
	q = getPrime(Factor_BitLength)
	p = getPrime(Factor_BitLength)
	N = p * q
	#Euler's totient function:
	phi = (p-1) * (q-1)

	#Generate Keys:
	while True:
		e = randint(1,phi)
		if gcd(e,phi) == 1:
			d = int(invert(e,phi))
			break

	#Generate Result:
	Pub_Key = (N,e)
	Prv_Key = (N,d)
	return Pub_Key,Prv_Key

Pub,Prv = KeyGen()

N = Pub[0]
e = Pub[1]
d = Prv[1]

#RSA Encrypt:
m = randint(1,N)
c = pow(m,e,N)

print(f'Pub_Key = {Pub}')
print(f'Prv_Key = {Prv}')
print(f'Encrypt_msg = {c}')

'''
Pub_Key = (547938466798424179, 80644065229241095)
Prv_Key = (547938466798424179, 488474228706714247)
Encrypt_msg = 344136655393256706
'''

flag = '0xGame{'+ MD5(m) +'}'
```



n比较小，直接分解

exp:

```python
from gmpy2 import *
import libnum
from Crypto.Util.number import *
from sage.all import *
from hashlib import md5

Pub_Key = (689802261604270193, 620245111658678815)
Encrypt_msg = 289281498571087475

# print(factor(Pub_Key[0]))
e=Pub_Key[1]
p=823642439
q=837502087
phi=(p-1)*(q-1)
d=gmpy2.invert(e,phi)
m=(md5(str(pow(Encrypt_msg,d,Pub_Key[0])).encode()).hexdigest())

print('0xGame{'+ m +'}')


```

### RSA-easy

给d了，直接解，或按照n分解打

exp：

```python
from gmpy2 import *
import libnum
from Crypto.Util.number import *
from sage.all import *
from hashlib import md5

Pub_Key = (547938466798424179, 80644065229241095)
Prv_Key = (547938466798424179, 488474228706714247)
Encrypt_msg = 344136655393256706



print(factor(Pub_Key[0]))
e=Pub_Key[1]
p=676191563
q=810330233
phi=(p-1)*(q-1)
d=gmpy2.invert(e,phi)
m=(md5(str(pow(Encrypt_msg,d,Pub_Key[0])).encode()).hexdigest())

print('0xGame{'+ m +'}')


```

### Code-Vigenere

题目描述：

```python
from secret import flag
from os import urandom
from base64 import b64encode

def Encrypt(msg, key):
    Lenth = len(key)
    result = ''

    upper_base = ord('A')
    lower_base = ord('a')
    KEY = [ord(key.upper()[_]) - upper_base for _ in range(Lenth)]

    index = 0
    for m in msg:
        tmp_key = KEY[index%Lenth] 
        if not m.isalpha():
            result += m
            continue

        if m.isupper(): 
            result += chr(upper_base + (ord(m) - upper_base + tmp_key) % 26)
        else: 
            result += chr(lower_base + (ord(m) - lower_base + tmp_key) % 26)
        index += 1
    return result

key = b64encode(urandom(6))[:5].decode()
print(Encrypt(flag,key))

#0lCcop{oyd94092-g8mq-4963-88b6-4helrxdhm6q7}
```



只有5位密钥，写一个解密函数，直接爆就行

exp:

```python
import string

stc=string.ascii_lowercase
def Encrypt(msg, key):
    Lenth = len(key)
    result = ''

    upper_base = ord('A')
    lower_base = ord('a')
    KEY = [ord(key.upper()[_]) - upper_base for _ in range(Lenth)]

    index = 0
    for m in msg:
        tmp_key = KEY[index%Lenth] 
        if not m.isalpha():
            result += m
            continue

        if m.isupper(): 
            result += chr(upper_base + (ord(m) - upper_base + tmp_key) % 26)
        else: 
            result += chr(lower_base + (ord(m) - lower_base + tmp_key) % 26)
        index += 1
    return result

def Decrypt(msg,key):
    Lenth = len(key)
    result = ''

    upper_base = ord('A')
    lower_base = ord('a')
    KEY = [ord(key.upper()[_]) - upper_base for _ in range(Lenth)]

    index = 0
    for m in msg:
        tmp_key = KEY[index%Lenth] 
        if not m.isalpha():
            result += m
            continue

        if m.isupper(): 
            result += chr(upper_base + (ord(m) - upper_base - tmp_key) % 26)
        else: 
            result += chr(lower_base + (ord(m) - lower_base - tmp_key) % 26)
        index += 1
    return result

flag_m="0lCcop{oyd94092-g8mq-4963-88b6-4helrxdhm6q7}"

for l_1 in stc:
    for l_2 in stc:
        for l_3 in stc:
            for l_4 in stc:
                for l_5 in stc:
                    key=l_1+l_2+l_3+l_4+l_5
                    if(Decrypt(flag_m,key).startswith("0xGame")):
                        print(Decrypt(flag_m,key),key)
   
```

### Number-Theory-CRT

题目描述:

```python
from Crypto.Util.number import bytes_to_long, getPrime
from hashlib import md5
from random import randint
from gmpy2 import invert,gcd

#Hash Function:
def MD5(m):return md5(str(m).encode()).hexdigest()

#RSA AlgorithmParameter Generation Function:
def KeyGen():
	Factor_BitLength = 30
	q = getPrime(Factor_BitLength)
	p = getPrime(Factor_BitLength)
	N = p * q
	#Euler's totient function:
	phi = (p-1) * (q-1)

	#Generate Keys:
	e = randint(1,phi)

	#Generate Result:
	Pub_Key = (N,e)
	return Pub_Key

Pub = KeyGen()

N = Pub[0]
e = Pub[1]

#RSA Encrypt:
m = randint(1,N)
c = pow(m,e,N)

print(f'Pub_Key = {Pub}')
print(f'Encrypt_msg = {c}')

'''
Pub_Key = (1022053332886345327, 294200073186305890)
Encrypt_msg = 107033510346108389
'''

flag = '0xGame{'+ MD5(m) +'}'
```



简单rsa，发现e和phi不互质，有2这个公因数，只能得到$m^2\ modn$,又因为m和n大小差不多，不能直接开方，换成
$$
m^2\ modp\\
m^2\ modq
$$
用Amm算法分别求解，然后crt得到结果

exp:

```python
from gmpy2 import *
import libnum
from Crypto.Util.number import *
from sage.all import *
from hashlib import md5
Pub_Key = (1022053332886345327, 294200073186305890)
Encrypt_msg = 107033510346108389
e=Pub_Key[1]
n=Pub_Key[0]

#print(factor(n))
c=Encrypt_msg
p=970868179
q=1052721013
print(factor(q-1))
print(factor(p-1))
phi=(p-1)*(q-1)

d=gmpy2.invert(e//2,phi)
m_2=pow(c,d,n)

m_2_p=m_2%p
m_2_q=m_2%q

m_p=pow(m_2_p,((p-1)//2+1)//2,p)

# for i in range(1,p-1):
    
#     if pow(i,(p-1)//2,p)!=1:
#         print(f"i={i}")
#         break
m_q=pow(m_2_q,(((q-1)//4)+1)//2,q)*pow(2,(q-1)//4,q)

m=crt([m_p,m_q], [p,q])

m=(md5(str(m).encode()).hexdigest())

print('0xGame{'+ m +'}')


```

 

### LFSR-baby

题目描述:

```python
from random import getrandbits
from secret import flag,seed
from hashlib import md5
 
 
def MD5(m):return md5(str(m).encode()).hexdigest()
 
class LFSR:
	def __init__(self, seed, Length):
		self.Length = Length
		assert seed.bit_length() < self.Length + 1
		self.Mask_seed  = 245818399386224174743537177607796459213
		self.state = self.init_state(seed)
		self.mask  = self.init_state(self.Mask_seed)
    
	def init_state(self, seed):
		result = [int(i) for i in bin(seed)[2:]]
		PadLenth = self.Length - len(result)
		result += [ 0 ] * PadLenth
		assert len(result) == self.Length
		return result
    
	def next(self):
		output = 0
		for i in range(self.Length):
			output ^= self.state[i] & self.mask[i] 
		self.state  =  self.state[ 1: ] + [output]
		return output
    
	def getrandbits(self,Length):
		result = []
		for _ in range(Length):
			result.append(str(self.next()))
		return int(''.join(result),2)
 
assert seed.bit_length() == 128
test = LFSR(seed,128)
print(test.Mask_seed)
print(test.getrandbits(128))
print(test.getrandbits(128))
 
assert flag == '0xGame{' + MD5(seed) + '}'
'''
245818399386224174743537177607796459213
103763907686833223776774671653901476306
136523407741230013545146835206624093442
'''
```

lfsr知道mark_seed和后256位求seed，这个题mark_seed的第一位是1，所以可以逐位倒推，这里用正向运算求下一位来推断上一位，而不是直接计算。

exp:

```python
from hashlib import md5

def MD5(m):return md5(str(m).encode()).hexdigest()
def init(num):
    result = [int(i) for i in bin(num)[2:]]
    PadLenth = 128 - len(result)
    result = [ 0 ] * PadLenth+result
    assert len(result) == 128
    return result

a=103763907686833223776774671653901476306
b=136523407741230013545146835206624093442
mask=init(245818399386224174743537177607796459213)
result = init(a)

for _ in range(128):
    result=[0]+result
    output=0
    for i in range(128):
        output ^= result[i] & mask[i] 
    if(output==result[128]):
        pass
    else:
        result[0]=1
    
seed=result[:128]

seed=int(''.join(map(str, seed)),2)

flag = '0xGame{' + MD5(seed) + '}'
print(flag)


```



### LFSR-easy

题目描述:
```python
from random import getrandbits
from secret import flag,Mask_seed
from hashlib import md5
 
 
def MD5(m):return md5(str(m).encode()).hexdigest()
 
class LFSR:
	def __init__(self, Mask_seed, Length):
		self.Length = Length
		assert Mask_seed.bit_length() < self.Length + 1
		self.seed  = 165943427582675380464843619836793254673 #getrandbits(self.Length)
		self.state = self.init_state(self.seed)
		self.mask  = self.init_state(Mask_seed)
    
	def init_state(self, seed):
		result = [int(i) for i in bin(seed)[2:]]
		PadLenth = self.Length - len(result)
		result += [ 0 ] * PadLenth
		assert len(result) == self.Length
		return result
    
	def next(self):
		output = 0
		for i in range(self.Length):
			output ^= self.state[i] & self.mask[i] 
		self.state  =  self.state[ 1: ] + [output]
		return output
    
	def getrandbits(self,Length):
		result = []
		for _ in range(Length):
			result.append(str(self.next()))
		return int(''.join(result),2)
 
assert Mask_seed.bit_length() == 128
test = LFSR(Mask_seed,128)
print(test.seed)
print(test.getrandbits(128))
print(test.getrandbits(128))
 
assert flag == '0xGame{' + MD5(Mask_seed) + '}'
'''
c0 = 165943427582675380464843619836793254673
c1 = 299913606793279087601607783679841106505
c2 = 192457791072277356149547266972735354901
'''
```

lfsr知道seed和生成的256位，推Mask，每次生成新的位相当于一个128位行向量乘一个列向量，128位的生成形成一个128*128矩阵乘列向量，求矩阵逆即可

tips:这个题的seed补全是在后面补全，后面生成的是在前面补全(自己写)

exp:

```python
from hashlib import md5
from sage.all import *
def MD5(m):return md5(str(m).encode()).hexdigest()
def init(num):
    result = [int(i) for i in bin(num)[2:]]
    PadLenth = 128 - len(result)
    result = [ 0 ] * PadLenth+result
    assert len(result) == 128
    return result

c0 = 165943427582675380464843619836793254673
c1 = 299913606793279087601607783679841106505
c2 = 192457791072277356149547266972735354901

print(c0.bit_length(),c1.bit_length(),c2.bit_length())
c0=init(c0*2)
c1=init(c1)
c2=init(c2)

M=matrix(GF(2),128,128)
for i in range(128):
    tmp=c0[i:]+c1[:i]
    
    for j in range(128):
        M[i,j]=tmp[j]
v = vector(GF(2), c1)

m=v*M.inverse()
mask=int(''.join(map(str, m)),2)

flag = '0xGame{' + MD5(mask) + '}'
print(flag)
```



### RC4

题目描述

task.py

```python
#!/usr/local/bin/python
from os import urandom
from random import choice
from hashlib import sha256
from string import ascii_letters, digits
 
from util import *
from secret import flag
 
def proof_of_work():
    proof = ''.join([choice(ascii_letters+digits) for _ in range(20)])
    _hexdigest = sha256(proof.encode()).hexdigest()
    print(f"[+] sha256(XXXX+{proof[4:]}) == {_hexdigest}")
    x = input('[+] Plz tell me XXXX: ')
    if len(x) != 4 or sha256( (x+proof[4:]).encode() ).hexdigest() != _hexdigest:
        return False
    return True
 
if __name__ == '__main__':
    assert proof_of_work()
    KEY = urandom(8)
    keystream = RC4(KEY)
 
    print("[+] Give me the text you want to encrypt:")
    m = input('>')
    c = Encrypt(m,keystream)
    print("[+] Here are the encrypt result:")
    print(f'c = {c}')
 
    keystream = RC4(KEY)
    print("[+] Give you the encrypted flag:")
    c = Encrypt(flag,keystream)
    print(f'c = {c}')
```

util.py

```python
from os import urandom
from secret import flag
 
def KSA(key):
    keylength = len(key)
 
    S = [i for i in range(256)]
 
    j = 0
    for i in range(256):
        j = (j + S[i] + key[i % keylength]) % 256
        S[i], S[j] = S[j], S[i]  # swap
 
    return S
 
def PRGA(S):
    i = 0
    j = 0
    while True:
        i = (i + 1) % 256
        j = (j + S[i]) % 256
        S[i], S[j] = S[j], S[i]  # swap
 
        K = S[(S[i] + S[j]) % 256]
        yield K
 
def RC4(key):
    S = KSA(key)
    return PRGA(S)
 
def Encrypt(plaintext,keystream):
    if type(plaintext) == bytes:
        pt = plaintext
    else:
        pt = bytes.fromhex(plaintext)
 
    result = b''
    for i in pt:
        result += bytes([i^next(keystream)])
    return result.hex()
```

没有靶机，了解这个题就行，主要就是采用同样的keysream使得两次异或可以消掉，得到flag，

$key\oplus m1=c1，key\oplus m2=c2$

再异或一次就行

